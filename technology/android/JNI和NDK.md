# JNI和NDK

## JNI 跟 NDK 的关系

`JNI`（`Java Native Interface`）是 `Java` 语言调用` Native`语言的一种特性，它定义了 `Java` 跟 `Native` 代码（C/C++）进行交互的方式。

`NDK`（`Native Development Kit`） 是 `Android` 中实现 `JNI` 的开发工具包，用于快速开发 `C/C++` 动态库（`.so`），并通过构建系统 `Grade`将动态库（`.so`）打包进应用 `APK`。`NDK`提供了交叉编译器，用于生成特定的 `CPU` 平台动态库。

## [安装及配置 NDK 和 CMake](https://developer.android.com/studio/projects/install-ndk?hl=zh-cn)

### hello-jni（ cmake 方式）

创建 `c++` 源文件，实现`native`方法：

```c++
//AndroidDemo/app/src/main/cpp/jni_tools.cpp
#include <jni.h>

extern "C" {
JNIEXPORT jstring JNICALL Java_cn_thismj_android_demo_jni_JniTools_helloWorld
        (JNIEnv *env, jclass) {
    return env->NewStringUTF("hello world!!!");
}
}
```

模块根目录创建 `CMakeLists.txt`文件：

```cmake
# 指定cmake允许的最小版本
cmake_minimum_required(VERSION 3.4.1)
# 创建一个库
add_library( # 指定库的名字
             hello-jni
             # 指定为动态库（共享库）
             SHARED
             # 指定库所包含的源文件的路径
             src/main/cpp/jni_tools.cpp)

# 查找预编译的库，并储存在指定的变量里面
find_library( # 指定变量名字
              log-lib
              # 指定预编译库的名字
              log )

# 指定库链接到目标库
target_link_libraries( # 指定目标库的名字
                       hello-jni

                       # 将日志库链接到目标库
                       ${log-lib} )
```

模块 `build.gradle`中关联`CMakeLists.txt`：

```groovy
android {
    ...
    externalNativeBuild {
        cmake {
            path file('src/CMakeLists.txt')
        }
    }
    ...
}
```

创建 `Java` 类以及 `native` 本地方法，静态代码块加载动态库 `libhelloJni.so`：

```java
//AndroidDemo/app/src/main/java/cn/thismj/android/demo/jni/JniTools.java
package cn.thismj.android.demo.jni;

public class JniTools {
    static {
        System.loadLibrary("helloJni");
    }
    public static native String helloWorld();
}

```

通过`JniTools`调用`native`方法，编译运行项目，可以在如下位置找到生成的动态库：

```bash
/AndroidDemo/app/build/intermediates/cmake/debug/obj/x86/libhello-jni.so
```

### Java 和 JNI 类型映射

基本类型：

| Java类型 | JNI类型  | 描述                  |
| -------- | -------- | --------------------- |
| boolean  | jboolean | unsigned 8 bits 整型  |
| byte     | Jbyte    | signed 8 bits 整型    |
| char     | jchar    | unsigned 16 bits 整型 |
| short    | jshort   | signed 16 bits 整型   |
| int      | jint     | signed 32 bits 整型   |
| long     | jlong    | signed 64 bits 整型   |
| float    | jfloat   | signed 32 bits 浮点型 |
| double   | jdouble  | signed 64 bits 浮点型 |

引用类型：

| Java类型  | JNI类型       | 描述                                       |
| --------- | ------------- | ------------------------------------------ |
| Object    | jobject       | 任何 java 对象，或者没有对应类型的java对象 |
| Class     | jclass        | Class类对象                                |
| String    | jstring       | 字符串                                     |
| Object[]  | jobjectArray  | 任何对象的数组                             |
| boolean[] | jbooleanArray | 布尔型数组                                 |
| byte[]    | jbyteArray    | byte数组                                   |
| ...       | ...           | /                                          |
| Throwable | jthrowable    | 表示java异常                               |
| void      | void          | /                                          |

* 引用类型不能直接使用，需要先根据`JNI`函数进行相应的转换	
* 多维数组(包括二维数组)都是引用类型，需要使用`jobjectArray`类型存取其值 

```c++
 //获得一维数组 的类引用，即jintArray类型
 jclass intArrayClass = env->FindClass("[I"); 
 //构造一个指向jintArray类一维数组的对象数组，该对象数组初始大小为dimion
 jobjectArray obejctIntArray  =  env->NewObjectArray(dimion ,intArrayClass , NULL);
 ...
```



### 注册`native`函数

#### 静态注册

`Java`调用`native`方法时，虚拟机通过遍历函数名字来找到对应的`JNI`函数，找到之后会建立关联关系，之后再调用时直接使用对应的`JNI`函数 ，所以`JNI`层的函数名字必须遵循特定的格式，可以通过 `javah`命令来辅助生成`JNI`对应的头文件：

```bash
 javah -d ./app/src/main/cpp -classpath ./app/src/main/java cn.thismj.android.demo.jni.JniTools
```

查看生成的头文件 `cn_thismj_android_demo_jni_JniTools.h`：

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class cn_thismj_android_demo_jni_JniTools */

#ifndef _Included_cn_thismj_android_demo_jni_JniTools
#define _Included_cn_thismj_android_demo_jni_JniTools
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     cn_thismj_android_demo_jni_JniTools
 * Method:    helloWorld
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_cn_thismj_android_demo_jni_JniTools_helloWorld
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif

```

由上可知，静态注册的`JNI`函数名字遵循以下格式：

```c++
JNIEXPORT return_type JNICALL Java_packagename_classname_methodname(JNIEnv *,jclass,..)
```

由于在`Java`中声明的`native`方法是静态的，所以第二个参数类型是`jclass`，如果是实例方法的话，则第二个参数类型是`jobject`。

#### 动态注册

在`c++`源文件中声明`JNI_OnLoad`方法，然后通过`JNIEnv`的`RegisterNatives`方法把`JNI`函数映射到`Java`中的`native`方法，而无需遵循特定的函数命名格式。每一个映射关系用一个`JNINativeMethod`结构体表示：

```c++
typedef struct {
    //Java中的native方法名字
    const char* name;
    //Java中native方法的签名，即传参与返回类型
    const char* signature;
    //对应c++中的函数指针
    void*       fnPtr;
} JNINativeMethod;
```

查看完整的动态注册代码：

```c++
#include <jni.h>
#include <android/log.h>

const char *LOG_TAG = "JniTools";
#define LOGD(FORMAT, ...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,FORMAT,##__VA_ARGS__)

extern "C" {
JNIEXPORT jstring JNICALL helloWorld
        (JNIEnv *env, jclass) {
    return env->NewStringUTF("dynamic hello world!!!");
}

//指定需要注册 native 方法的 Java 类全名，"."替换为"/"
static const char *class_name = "cn/thismj/android/demo/jni/JniTools";
//此处是一个 JNINativeMethod 数组，可以映射多个 native 方法
static const JNINativeMethod methods[] = {
        //映射 JniTools 类中的 helloWorld 方法（没有传参且返回类型是String）为当前 c++ 的 helloWorld 方法，
        {"helloWorld", "()Ljava/lang/String;", (void *) (helloWorld)}
};

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    LOGD("jni tools onLoad");

    JNIEnv *env = nullptr;
    //获取当前线程环境的 JNIEnv 指针
    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }

    jclass clazz = env->FindClass(class_name);
    if (clazz == nullptr) {
        LOGD("can not find %s", class_name);
        return JNI_ERR;
    }

    //动态注册 native 方法
    if (env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(JNINativeMethod)) < 0) {
        LOGD("register natives error");
        return JNI_ERR;
    }
    //指定使用的 JNI 版本，如果没有声明 JNI_OnLoad 函数，则默认为老的 JNI_VERSION_1_1 版本
    return JNI_VERSION_1_6;
}
}
```

#### 方法签名

`Java`是支持方法重载的，在跟`JNI`函数做映射的时候，仅仅通过方法名字无法找到重载的函数，所以衍生了一个签名的概念，即`Java`方法的传参和返回类型的信息。

`JNI`规范定义的签名信息具体格式如下所示：

```bash
(参数1类型标示;参数2类型标示;参数3类型标示...)返回值类型标示
```

例如：

```java
//对应的签名为：（Ljava/util/String;I）Ljava/util/String;
public string addTail(String tail, int index)
```

```java
//对应的签名为：（ILjava/util/String;[I)I
public int addValue(int index, String value,int[] arr)
```

`java`类型与签名类型标示的映射：

| Java类型 | 类型标示            | 备注                                    |
| -------- | ------------------- | --------------------------------------- |
| boolean  | Z                   | B被byte占了，改用Z |
| byte     | B                   | / |
| char     | C                   | / |
| short    | S                   | / |
| int      | I                   | / |
| long     | J                   | L被引用类型占了，改用J |
| float    | F                   | / |
| double   | D                   | / |
| void     | V                   | 空返回类型                            |
| int[]    | [I                  | 数组类型为"[类型标示" |
| float[]  | [F                  | / |
| ... | ...               | ... |
| String   | Ljava/lang/String;  | 引用类型标示为"L包名;"，包名的"."换成"/" |
| String[] | [Ljava/lang/String; | / |

### Native调用Java代码

`jni.h`中定义了一系列函数来支持`native`调用`java`代码，每个函数都通过`JNIEnv`参数调用，`JNIEnv`类型是指向一个存放所有`JNI`函数指针的指针。

举例，创建`Java`测试类，用来在`c++`调用`Java`代码：

```java
package cn.thismj.android.demo.jni;

import android.util.Log;
public class JniTestType {
    private int testInt;
    private boolean testBoolean;
  
    public JniTestType(int testInt, boolean testBoolean) {
        this.testInt = testInt;
        this.testBoolean = testBoolean;
    }
  
    private void testMethod(){
        Log.d("JniTools","来自native的call");
    }
}
```



#### 查找类

```c++
jclass clazz = env->FindClass("cn/thismj/android/demo/jni/JniTestType");
```

#### 创建对象

```c++
//通过构造函数创建对象
jmethodID constructor = env->GetMethodID(clazz, "<init>", "(IZ)V");
//NewObject
jobject object = env->NewObject(clazz, constructor, 520, false);
//NewObjectA
jvalue args[] = {
    {.i = 520},
    {.z = false}
 };
jobject object = env->NewObjectA(clazz, constructor, args);

//通过 AllocObject 直接分配对象，并返回引用
jobject allocObject = env->AllocObject(clazz);
```

#### 设置字段值

```c++
//获取字段id
jfieldID testIntField = env->GetFieldID(clazz, "testInt", "I");
jfieldID testBooleanField = env->GetFieldID(clazz, "testBoolean", "Z");
//设置字段值
env->SetIntField(object, testIntField, 521);
env->SetBooleanField(object, testBooleanField, true);
```

#### 获取字段值

```c++
env->GetIntField(object, testIntField);
env->GetBooleanField(object, testBooleanField);
```

#### 调用方法

```c++
jmethodID testMethod = env->GetMethodID(clazz, "testMethod", "()V");
env->CallVoidMethod(object, testMethod);
```

#### 字符串操作


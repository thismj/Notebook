# 算法

## hash相关

[[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]),i};
            }
            map.put(nums[i],i);
        }
        return new int[0];
    }
}
```

[[387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

```java
//Hash法 32ms
class Solution {
    public int firstUniqChar(String s) {
        char[] chars = s.toCharArray();
        Map<Character,Integer> map = new HashMap<>();
        for(char c:chars){
            map.put(c,map.getOrDefault(c, 0)+1);
        }
        for(int i = 0;i < s.length();i++){
            if(map.get(s.charAt(i))==1){
                return i;
            }
        }
        return -1;
    }
}
```

```java
//数组法（适用于都是小写字母）6ms
class Solution {
    public int firstUniqChar(String s) {
        char[] chars = s.toCharArray();
        int[] array = new int[26];
        for(char c:chars){
            array[c-'a']++;
        }
        for(int i = 0;i < s.length();i++){
            if(array[chars[i]-'a']==1){
                return i;
            }
        }
        return -1;
    }
}
```

## 链表操作

[[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)](https://leetcode-cn.com/problems/add-two-numbers/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null;
        ListNode tail = null;
        int carry = 0;
        while(l1 != null || l2 != null){
            int a = (l1 != null?l1.val:0);
            int b = (l2 != null?l2.val:0);
            int sum = a + b + carry;
            int c = sum % 10;
            if(head == null){
                head = tail = new ListNode(c);
            } else {
                tail.next = new ListNode(c); 
                tail = tail.next;
            }

            if(l1 != null){
                l1 = l1.next;
            }

            if(l2 != null){
                l2 = l2.next;
            }
            carry = sum / 10;
        }

        if(carry > 0){
            tail.next = new ListNode(carry);
        }

        return head;
    }
}
```

[[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

借助栈、哑节点的方式：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummpy = new ListNode(0, head);
        ListNode cur = dummpy;
        Deque<ListNode> stack = new LinkedList();
        while (cur != null){
            stack.push(cur);
            cur = cur.next;
        }
        for(int i = 0;i < n;i++){
            stack.pop();
        }
        ListNode pre = stack.peek();
        pre.next = pre.next.next;
        return dummpy.next;
    }
}
```

快慢指针：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummpy = new ListNode(0,head);
        ListNode fast = dummpy;
        ListNode slow = dummpy;
        for(int i = 0; i< n; i++){
            fast = fast.next;
        }

        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummpy.next;
    }
}
```

[[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```java
//自己写的
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummpy = new ListNode(0, head);
        ListNode pre = dummpy;
        ListNode tail;
        while(pre != null){
            tail = pre;
            for(int i = 0; i < k; i++){
                tail = tail.next;
                if(tail == null){
                    return dummpy.next;
                }
            }
            ListNode p = pre.next;
            ListNode newPre = p;
            pre.next = tail;
            ListNode prev = tail.next;
            while (prev != tail){
                ListNode next = p.next;
                p.next = prev;
                prev = p;
                p = next;
            }
            pre = newPre;
        }
        return dummpy.next;
    }
}
```

[[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)](https://leetcode-cn.com/problems/rotate-list/)

```java
//自己写的，击败了5%的用户，哈哈哈。。。。
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(k == 0 || head == null || head.next == null){
            return head;
        }
        ListNode h = head;
        int size = 0;
        while(h != null){
            h = h.next;
            size++;
        }
        int count = k % size;
        for(int i = 0; i<count; i++){
            ListNode first = head;
            while(head.next != null){
                ListNode next = head.next;
                if(head.next.next==null){
                    head.next = null;
                }
                head = next;
            }
            head.next = first;
        }
        return head;
    }
}
```

```java
//快慢指针法
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(k == 0 || head == null || head.next == null){
            return head;
        }
        ListNode temp = head;
        int size = 0;
        while(temp != null){
            temp = temp.next;
            size++;
        }
        int count = k % size;
        if(count == 0){
            return head;
        }
        ListNode slow = head;
        ListNode fast = head;
        while(count-- > 0){
            fast = fast.next;
        }
        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        ListNode newHead = slow.next;
        slow.next = null;
        fast.next = head;
        return newHead;
    }
}
```

[[138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    private Map<Node,Node> map= new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }

        Node newNode = copyNode(head);
        Node oldNode = head;
        while(oldNode != null){
            newNode.next = copyNode(oldNode.next);
            newNode.random = copyNode(oldNode.random);
            newNode = newNode.next;
            oldNode = oldNode.next;
        }
        return map.get(head);
    }

    private Node copyNode(Node node){
        if(node == null){
            return null;
        }
        if(!map.containsKey(node)){
            map.put(node, new Node(node.val));
        } 
        return map.get(node);
    }
}
```

[[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
//自己写的
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode current = head;
        ListNode next = current.next;
        ListNode temp;
        while(next != null){
            temp = next.next;
            next.next = current;
            current = next;
            next = temp;
        }
        head.next = null;
        return current;
    }
}
```

```java
//遍历法
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        ListNode temp = null;
        while (cur != null){
            temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;
    }
}
```

```java
//递归
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        //找到反转之后的头结点
        ListNode newHead = reverseList(head.next);
        //然后依次从原先的链表尾部反转操作
        head.next.next = head;
        head.next = null;
        //返回的始终是反转之后的头结点
        return newHead;
    }
}
```

## 树的遍历

[[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//递归法
class Solution {
    private List<Integer> orderList = new ArrayList();
    public List<Integer> inorderTraversal(TreeNode root) {
        traversal(root);
        return orderList;
    }

    private void traversal(TreeNode root){
        if(root == null){
            return;
        }
        traversal(root.left);
        orderList.add(root.val);
        traversal(root.right);
    }
}
```

```java
//栈迭代法
class Solution {
    private List<Integer> orderList = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null){
            return orderList;
        }
        Deque<TreeNode> stack = new LinkedList<>();
        while(root != null){
            stack.push(root);
            root = root.left;
        }

        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            orderList.add(node.val);
            TreeNode right = node.right;
            while(right != null){
                stack.push(right);
                right = right.left;
            }
        }
        return orderList;
    }
}
```

[[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```java
//递归法
class Solution {
    private List<Integer> orderList = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        traversal(root);
        return orderList;
    }

    private void traversal(TreeNode root){
        if(root == null){
             return;
        }
        orderList.add(root.val);
        traversal(root.left);
        traversal(root.right);
    }
}
```

```java
//迭代法
class Solution {
    private List<Integer> orderList = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null){
            return orderList;
        }
        Deque<TreeNode> stack = new LinkedList();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node == null){
                continue;
            }
            orderList.add(node.val);
            stack.push(node.right);
            stack.push(node.left);
        }
        return orderList;
    }
}
```

[[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```java
//递归法
class Solution {
    private List<Integer> orderList = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        traversal(root);
        return orderList;
    }

    private void traversal(TreeNode root){
        if(root == null){
            return;
        }
        traversal(root.left);
        traversal(root.right);
        orderList.add(root.val);
    }
}
```

```java
//迭代法
class Solution {
    private List<Integer> orderList = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root == null){
            return orderList;
        }
        Deque<TreeNode> stack = new LinkedList<>();
        while(root != null){
            stack.push(root);
            root = root.left;
        }

        TreeNode pre = null;
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node.right == null || node.right == pre){
                orderList.add(node.val);
                pre = node;
            } else {
                stack.push(node);
                TreeNode right = node.right;
                while(right != null){
                    stack.push(right);
                    right = right.left;
                }
            }
        }
        return orderList;
    }
}
```

[[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> levelOrderList = new ArrayList<>();
        if(root == null){
            return levelOrderList;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int size = 1;
        int count = 0;
        
        List<Integer> first = new ArrayList<>();
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            size--;
            first.add(node.val);
            if(node.left != null){
                queue.offer(node.left);
                count++;
            }

            if(node.right != null){
                queue.offer(node.right);
                count++;
            }

            if(size == 0){
                size = count;
                count = 0;
                levelOrderList.add(first);
                first = new ArrayList<>();
            } 
        }
        return levelOrderList;
    }
}
```

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> levelOrderList = new ArrayList<>();
        if(root == null){
            return levelOrderList;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while(!queue.isEmpty()){
            List<Integer> levelList = new ArrayList<>();
            levelOrderList.add(levelList);
            int levelSize = queue.size();
            for(int i = 0;i < levelSize;i++){
               TreeNode node = queue.poll();
               levelList.add(node.val);

               if(node.left != null){
                 queue.offer(node.left);
               }

               if(node.right != null){
                 queue.offer(node.right);
               }
            }
        }
        return levelOrderList;
    }
}
```


{"./":{"url":"./","title":"知识笔记","keywords":"","body":"学习笔记整理 旨在建立自己的知识体系，成为一个胸有成竹的人 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-11 15:47:55 "},"java/":{"url":"java/","title":"Java","keywords":"","body":"Java Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-02 20:12:46 "},"java/Java注解.html":{"url":"java/Java注解.html","title":"Java注解","keywords":"","body":"Java注解 Java注解（也被称为元数据），为我们再代码中添加信息提供了一种形式化的方法。 内置标准注解： @Override （1.5） 表示当前方法将覆盖父类的方法，如果方法名称或者签名对不上，则编译器会提示错误信息 @Deprecated（1.5） 标记当前元素已过时，编译器会给出警告 @SuppressWarnings（1.5） 关闭编译器警告信息，通过字符串来指定需要关闭的编译警告类型，支持的编译警告类型取决于使用的编译器或IDE @SafeVarargs （1.7） 表明该方法内部不会执行类型不安全的操作，可注解于构造函数或者 static、final 修饰的方法，让编译器不提示 \"unchecked\" 警告 @FunctionalInterface （1.8） 表明这是个函数式接口（可转换为 lambda 表达式），如果该接口里面不止一个抽象方法，则编译器会提示错误信息 内置元注解（负责注解其它的注解） @Target：指定该注解可用的作用域，ElementType 枚举类型包括： ElementType 作用域 TYPE 类、接口、枚举 FIELD 类字段（包括枚举常量） METHOD 方法 PARAMETER 参数 CONSTRUCTOR 构造函数 LOCAL_VARIABLE 局部变量 ANNOTATION_TYPE 注解类型 PACKAGE 包 TYPE_PARAMETER 泛型参数（1.8） TYPE_USE 类型名称（1.8） @Retention：指定注解保留的阶段，RetentionPolicy 枚举类型包括： RetentionPolicy 阶段 SOURCE 仅保留在源码阶段，会被编译器丢弃 CLASS 编译时保留在 class 文件中，VM运行时丢弃 SOURCE 保留到VM运行时，可以通过反射获取信息 @Documented：指定生成 JavaDoc 时包含该注解 @Inherited：指定该注解作用在 class 上时，子类可以继承父类的注解 @Native：表示定义常量值的字段可以被 native 代码引用（1.8） @Repeatable：指定一个容器注解，使该注解可以在一个元素上重复使用（1.8）： @Repeatable(Authorities.class) public @interface Authority { String role(); } public @interface Authorities { Authority[] value(); } public class RepeatAnnotationUseNewVersion { @Authority(role=\"Admin\") @Authority(role=\"Manager\") public void doSomeThing(){ } } 注解处理器 apt（Annotation processing tool）是 javac 的一个工具 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-06-18 21:15:41 "},"android/":{"url":"android/","title":"Android","keywords":"","body":"Android Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-21 17:36:45 "},"android/Jetpack导航组件.html":{"url":"android/Jetpack导航组件.html","title":"Jetpack导航组件","keywords":"","body":"Jetpack导航组件 导航原则 每个 APP 都有一个固定的首页，即用户在 Luncher 启动 APP 时首先看到的页面以及点击返回键回到 Launcher 时最后看到的页面（不考虑欢迎跟登录注册等页面）。 页面导航通过栈的形式来表示，当前页面在栈顶，固定的首页在栈底。 在当前 APP 任务里面，标题栏的向上按钮跟系统状态栏的返回键的作用是一样的。 当 APP 回到首页的时候，不应该显示标题栏上的向上按钮，只能通过系统的返回键退出当前 APP 。 Deep Link 进当前 APP 时，需要清除掉 APP 原有的页面栈，并模拟生成手动导航到Deep Link 页面的页面栈，此时点击标题栏的向上按钮可以一步一步回到首页，而点击返回键应该回到产生 Deep Link 的地方。 导航组件 主要包含三个部分： 导航图：用 xml 文件集中描述页面相关的所有信息（ res/navigation 资源文件夹） NavHost：页面的空白容器（ 默认实现为 NavHostFragment ） NavController：管理和控制导航页面，通知 NavHost 导航到相应页面 使用入门 DrawerLayout + 导航组件实现侧边栏导航： 添加依赖 dependencies { def nav_version = \"2.1.0\" implementation \"androidx.navigation:navigation-fragment:$nav_version\" implementation \"androidx.navigation:navigation-ui:$nav_version\" } 添加导航图 在 res/navigation 目录添加导航描述文件： Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-21 21:39:41 "},"android/Jetpack Lifecycles-LiveData-ViewModel.html":{"url":"android/Jetpack Lifecycles-LiveData-ViewModel.html","title":"Jetpack Lifecycles-LiveData-ViewModel","keywords":"","body":"Jetpack Lifecycles-LiveData-ViewModel Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-21 17:31:07 "}}
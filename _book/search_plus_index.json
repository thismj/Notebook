{"./":{"url":"./","title":"知识笔记","keywords":"","body":"学习笔记整理 旨在建立自己的知识体系，成为一个胸有成竹的人 [ ] 一天一个知识点 [x] 怕是吹牛逼 print [x + 1 for x in range(10)] Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-14 20:02:23 "},"Java基础/":{"url":"Java基础/","title":"Java基础","keywords":"","body":"Java基础 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"Java基础/part1.html":{"url":"Java基础/part1.html","title":"基本类型","keywords":"","body":"基本类型 java 中共有几种基本数据类型？每种类型各占多少个字节数？ 类的成员变量、基本类型数组 → 方法区（Method Area） 局部变量、方法参数 → 虚拟机栈中栈帧的局部变量表（Local Variables） 虚拟机栈中栈帧的操作数栈（Operand Stack） int 与 integer 的区别？自动装箱与自动拆箱？ Integer 内部类 IntegerCache 保存了 [-128, 虚拟机参数指定最大值] 的对象缓存 写个例子用 javap 查看字节码，发现自动装箱与自动拆箱实际上等同于 Integer 的 valueOf() 以及 intValue() 方法 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-14 21:13:23 "},"Java基础/part2.html":{"url":"Java基础/part2.html","title":"==、equals和hashCode","keywords":"","body":"==、equals() 和 hashCode() Java 中 ==、equals() 和 hashCode() 的作用以及区别？ 利用 Objects 类来比较 equals() 以及重写 hashCode() 方法，规避空指针 重写 equals() 方法的原则? 自反性（Reflexive） 对称性（Symmetric） 传递性（Transitive） 一致性（Consistent） 对任何非空对象 x， x.equals(null) 必定为 false 重写 hashCode() 方法的原则？ 在程序执行期间，只要 equals() 方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode() 方法必须始终如一地返回同一个整数 如果两个对象通过 equals() 方法比较得到的结果是相等的，那么对这两个对象进行 hashCode() 得到的值应该相同 两个不同的对象，hashCode() 的结果可能是相同的，这就是哈希表中的冲突。为了保证哈希表的效率，哈希算法应尽可能的避免冲突 为什么重写 equals() 方法后一定也要重写 hashCode() 方法？ Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-14 20:33:53 "},"Java基础/part3.html":{"url":"Java基础/part3.html","title":"String、StringBuffer和StringBuilder","keywords":"","body":"String、StringBuffer和StringBuilder String.intern() 方法的作用？ 如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。在HotSpot虚拟机里面，Java 1.6以及之前的版本，是直接把字符串添加到常量池，1.7版本因为字符串常量池移到了堆内存，所以是把堆内存中该字符串的引用保存在常量池。 String为什么不可变？为什么String类被设计成不可变的？ final修饰、内部是一个char数组的私有变量、完美封装 安全性（线程安全、防止接口数据篡改） 字符串常量池，节省空间 因为不可变，可以缓存hashCode，适合做Map类集合的Key String、StringBuffer 和 StringBuilder 区别？ String是不可变的，StringBuffer 和 StringBuilder是可变的，都是final修饰，内部都是char[]数组，但是StringBuffer 和 StringBuilder实现Appendable来实现可变。 StringBuffer是线程安全的，StringBuilder是线程不安全的，不考虑多线程应该用StringBuilder，避免没必要的线程同步消耗。 代码里面如果循环地用 \"+\" 拼接字符串应该改用 StringBuilder或StringBuffer；简单的\"a\"+\"b\"+\"c\"这种在编译期就能确定的字符串用\"+\"直接拼接效率最好；假设a是一个字符串变量，那a+\"b\"这样的代码，通过反汇编class文件发现等同于使用StringBuilder。 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 10:35:26 "},"Java进阶/":{"url":"Java进阶/","title":"Java进阶","keywords":"","body":"Java进阶 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"Java进阶/part2.html":{"url":"Java进阶/part2.html","title":"Java静态代理与动态代理","keywords":"","body":"Java静态代理与动态代理 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"Android/":{"url":"Android/","title":"JVM","keywords":"","body":"JVM Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"jvm/part1.html":{"url":"jvm/part1.html","title":"JVM运行时数据区","keywords":"","body":"JVM运行时数据区 JVM虚拟机规范定义的运行时数据区（JVM内存模型）？ 程序计数器 Java虚拟机栈 - 栈帧Frame - （局部变量表Local Variables+操作数栈Operand Stack+动态链接Dynamic Linking+方法出口） 本地方法栈 堆 方法区（HotSpot的实现，1.7以前称之为永久代PermGen，1.8称之为Metaspace元空间） HotSpot虚拟机 1.6、1.7、1.8运行时数据区的主要差异？ 1.7把运行时常量池从永久代PermGen移到堆内存中，为什么？ 1.8移除永久代，增加元空间（Metaspace本地内存），为什么？ Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-16 21:14:00 "},"计算机网络/":{"url":"计算机网络/","title":"计算机网络","keywords":"","body":"计算机网络 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"计算机组成原理/":{"url":"计算机组成原理/","title":"计算机组成原理","keywords":"","body":"计算机组成原理 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 14:30:12 "},"数据结构/":{"url":"数据结构/","title":"数据结构","keywords":"","body":"数据结构 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"算法/":{"url":"算法/","title":"算法","keywords":"","body":"算法 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"版本管理/":{"url":"版本管理/","title":"版本管理","keywords":"","body":"版本管理 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 14:30:12 "},"版本管理/part1.html":{"url":"版本管理/part1.html","title":"Git常用命令","keywords":"","body":"Git常用命令 git config //查看当前目录Git配置信息 git config --list //查看全局Git配置信息 git config --global --list //查看当前目录Git配置的用户邮箱 git config user.email //配置当前目录Git的用户名字 git config user.name \"ThisMJ\" git subtree //父仓库中添加子仓库， git subtree add --prefix=_book git@github.com:thismj/Notebook.git gh-pages --squash //从源仓库拉取更新 git subtree push --prefix=_book git@github.com:thismj/Notebook.git gh-pages //推送本地修改到源仓库 git subtree push --prefix=_book git@github.com:thismj/Notebook.git gh-pages Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 16:08:41 "}}
{"./":{"url":"./","title":"知识笔记","keywords":"","body":"学习笔记整理 旨在建立自己的知识体系，成为一个胸有成竹的人 [ ] 一天一个知识点 [x] 怕是吹牛逼 print [x + 1 for x in range(10)] Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-14 20:02:23 "},"Java基础/":{"url":"Java基础/","title":"Java基础","keywords":"","body":"Java基础 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"Java基础/part1.html":{"url":"Java基础/part1.html","title":"基本类型","keywords":"","body":"基本类型 java 中共有几种基本数据类型？每种类型各占多少个字节数？ 类的成员变量、基本类型数组 → 方法区（Method Area） 局部变量、方法参数 → 虚拟机栈中栈帧的局部变量表（Local Variables） 虚拟机栈中栈帧的操作数栈（Operand Stack） int 与 integer 的区别？自动装箱与自动拆箱？ Integer 内部类 IntegerCache 保存了 [-128, 虚拟机参数指定最大值] 的对象缓存 写个例子用 javap 查看字节码，发现自动装箱与自动拆箱实际上等同于 Integer 的 valueOf() 以及 intValue() 方法 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-14 21:13:23 "},"Java基础/part2.html":{"url":"Java基础/part2.html","title":"==、equals和hashCode","keywords":"","body":"==、equals() 和 hashCode() Java 中 ==、equals() 和 hashCode() 的作用以及区别？ 利用 Objects 类来比较 equals() 以及重写 hashCode() 方法，规避空指针 重写 equals() 方法的原则? 自反性（Reflexive） 对称性（Symmetric） 传递性（Transitive） 一致性（Consistent） 对任何非空对象 x， x.equals(null) 必定为 false 重写 hashCode() 方法的原则？ 在程序执行期间，只要 equals() 方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode() 方法必须始终如一地返回同一个整数 如果两个对象通过 equals() 方法比较得到的结果是相等的，那么对这两个对象进行 hashCode() 得到的值应该相同 两个不同的对象，hashCode() 的结果可能是相同的，这就是哈希表中的冲突。为了保证哈希表的效率，哈希算法应尽可能的避免冲突 为什么重写 equals() 方法后一定也要重写 hashCode() 方法？ Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-14 20:33:53 "},"Java基础/part3.html":{"url":"Java基础/part3.html","title":"String、StringBuffer和StringBuilder","keywords":"","body":"String、StringBuffer和StringBuilder String.intern() 方法的作用？ 如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。在HotSpot虚拟机里面，Java 1.6以及之前的版本，是直接把字符串添加到常量池，1.7版本因为字符串常量池移到了堆内存，所以是把堆内存中该字符串的引用保存在常量池。 String为什么不可变？为什么String类被设计成不可变的？ final修饰、内部是一个char数组的私有变量、完美封装 安全性（线程安全、防止接口数据篡改） 字符串常量池，节省空间 因为不可变，可以缓存hashCode，适合做Map类集合的Key String、StringBuffer 和 StringBuilder 区别？ String是不可变的，StringBuffer 和 StringBuilder是可变的，都是final修饰，内部都是char[]数组，但是StringBuffer 和 StringBuilder实现Appendable来实现可变。 StringBuffer是线程安全的，StringBuilder是线程不安全的，不考虑多线程应该用StringBuilder，避免没必要的线程同步消耗。 代码里面如果循环地用 \"+\" 拼接字符串应该改用 StringBuilder或StringBuffer；简单的\"a\"+\"b\"+\"c\"这种在编译期就能确定的字符串用\"+\"直接拼接效率最好；假设a是一个字符串变量，那a+\"b\"这样的代码，通过反汇编class文件发现等同于使用StringBuilder。 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 10:35:26 "},"Java基础/part4.html":{"url":"Java基础/part4.html","title":"理解面向对象的三大特性","keywords":"","body":"理解面向对象的三大特性 封装 暴露接口，封装实现细节 继承 静态属性和静态方法是否可以被继承？是否可以被重写？为什么？ 什么是多态？多态存在的三个必要条件？ 继承 重写 向上转型 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 16:14:55 "},"Java基础/part5.html":{"url":"Java基础/part5.html","title":"抽象类和接口","keywords":"","body":"抽象类和接口 抽象类和接口的区别？ 抽象类和接口的意义？ 抽象类和接口的使用场景？ Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 21:21:16 "},"Java基础/part6.html":{"url":"Java基础/part6.html","title":"理解泛型","keywords":"","body":"理解泛型 理解泛型通配符 ：协变，生产者，提供 Fruit 或者 Fruit 的子类。List不能 add 任何元素，可以 get 元素出来。 ：逆变，消费者，接收 Fruit 或者 Fruit 的子类，List可以添加 Fruit 以及 Fruit 的子类元素。 ：无类型，List不能添加任何元素。 可不可以创建泛型类数组？为什么？ 不可以，因为泛型擦除会导致泛型类数组类型不安全。 什么是泛型擦除？ 泛型信息在编译的时候会被擦除成它的边界，JVM里面是没有泛型相关的信息的。 → T 被擦除成 Object → T 被擦除成 Fruit → T 被擦除成 Fruit Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 20:51:12 "},"Java进阶/":{"url":"Java进阶/","title":"Java进阶","keywords":"","body":"Java进阶 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"Java进阶/part2.html":{"url":"Java进阶/part2.html","title":"Java静态代理与动态代理","keywords":"","body":"Java静态代理与动态代理 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"Android/":{"url":"Android/","title":"JVM","keywords":"","body":"JVM Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"jvm/part1.html":{"url":"jvm/part1.html","title":"JVM运行时数据区","keywords":"","body":"JVM运行时数据区 JVM虚拟机规范定义的运行时数据区（JVM内存模型）？ 程序计数器 Java虚拟机栈 - 栈帧Frame - （局部变量表Local Variables+操作数栈Operand Stack+动态链接Dynamic Linking+方法出口） 本地方法栈 堆 方法区（HotSpot的实现，1.7以前称之为永久代PermGen，1.8称之为Metaspace元空间） HotSpot虚拟机 1.6、1.7、1.8运行时数据区的主要差异？ 1.7把运行时常量池从永久代PermGen移到堆内存中，为什么？ 1.8移除永久代，增加元空间（Metaspace本地内存），为什么？ Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-16 21:14:00 "},"计算机网络/":{"url":"计算机网络/","title":"计算机网络","keywords":"","body":"计算机网络 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"计算机组成原理/":{"url":"计算机组成原理/","title":"计算机组成原理","keywords":"","body":"计算机组成原理 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 14:30:12 "},"数据结构/":{"url":"数据结构/","title":"数据结构","keywords":"","body":"数据结构 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"数据结构/part1.html":{"url":"数据结构/part1.html","title":"单链表","keywords":"","body":"单链表 单链表 c++ 实现 ```c++ template struct ListNode { //数据域 T data; //指针域 ListNode *next; }; template class LinkedList { public: LinkedList(); //插入数据到指定的位置 void Insert(int index, T data); //删除指定位置的数据 void Delete(int index); //更新指定位置的数据 void Update(int index, T data); //获取指定位置的数据 T Get(int index); //返回链表数据个数 int Size(); //依次打印所有的数据 void Print(); //头结点 ListNode *head; private: //返回指定位置的结点指针 ListNode *findNode(int index); //记录数据个数 int size; }; 实现findNode() 方法，方便后续查找、删除、插入、更新等操作： /** * 此方法用来返回单链表指定位置的结点指针，方便进行插入、删除、更新等操作 */ template ListNode *LinkedList::findNode(int index) { if (index = size) { throw std::invalid_argument(\"Find Error Index:\" + to_string(index)); } ListNode *current = head; int position = 0; while (position next; position++; } return current; } 查找元素： template T LinkedList::Get(int index) { ListNode *node = findNode(index); return node->data; } 插入元素： template void LinkedList::Insert(int index, T data) { auto *node = new ListNode(); node->data = data; if (index == 0) { node->next = head; head = node; } else { ListNode *pre = findNode(index - 1); node->next = pre->next; pre->next = node; } size++; } 删除元素： template void LinkedList::Delete(int index) { ListNode *pre; ListNode *current; if (index == 0) { pre = head; } else { pre = findNode(index - 1); } current = findNode(index); pre->next = current->next; delete current; size--; } 更新元素： template void LinkedList::Update(int index, T data) { ListNode *current = findNode(index); current->data = data; } 迭代法逆转单链表方法一： /** * 通过迭代方式反转单链表 * @return 新的头结点 */ template ListNode *ReverseByIterate(ListNode *head) { if (!head || !head->next) { return head; } ListNode *pre = head; ListNode *current = head->next; ListNode *temp; while (current) { temp = current->next; current->next = pre; pre = current; current = temp; } head->next = nullptr; return pre; } 迭代法逆转单链表方法一： /** * 依次把后面的结点插入到头结点前面反转单链表 * @return 新的头结点 */ template ListNode *ReverseByInsert(ListNode *head) { if (!head || !head->next) { return head; } ListNode *current = head->next; head->next = nullptr; ListNode *temp; while (current) { temp = current->next; current->next = head; head = current; current = temp; } return head; } 递归法逆转单链表： /** * 通过递归方式反转单链表 * @return 新的头结点 */ template ListNode *ReverseByRecursive(ListNode *head) { if (!head || !head->next) { return head; } ListNode *current = ReverseByRecursive(head->next); head->next->next = head; head->next = nullptr; return current; } Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-31 20:35:31 "},"数据结构/part2.html":{"url":"数据结构/part2.html","title":"二叉树","keywords":"","body":"二叉树 二叉树 c++ 实现 ```c++ /** * 二叉树结点定义 * @param data 数据域 * @param left 左孩子结点 * @param right 右孩子结点 */ template struct TreeNode { T data; TreeNode *left; TreeNode *right; }; template class BinaryTree { public: BinaryTree(); void CreateTree(); void Preorder(); void InOrder(); void PostOrder(); int Size(); //根结点 TreeNode *root; private: int size; TreeNode *InnerCreateTree(TreeNode *root); void InnerPreorder(TreeNode *root); void InnerInOrder(TreeNode *root); void InnerPostOrder(TreeNode *root); }; 前序生成二叉树： /** * 前序生成二叉树 */ template void BinaryTree::CreateTree() { root = InnerCreateTree(root); } template TreeNode *BinaryTree::InnerCreateTree(TreeNode *root) { char data; if ((data = getchar()) == '#') { root = nullptr; } else { root = new TreeNode; root->data = data; cout left = InnerCreateTree(root->left); root->right = InnerCreateTree(root->right); } return root; } 前序遍历二叉树： /** * 前序遍历二叉树 */ template void BinaryTree::Preorder() { InnerPreorder(root); } template void BinaryTree::InnerPreorder(TreeNode *root) { if (!root) { return; } cout data left); InnerPreorder(root->right); } 中序遍历二叉树： /** * 中序遍历二叉树 */ template void BinaryTree::InOrder() { InnerInOrder(root); } template void BinaryTree::InnerInOrder(TreeNode *root) { if (!root) { return; } InnerPreorder(root->left); cout data right); } 后序遍历二叉树： /** * 后序遍历二叉树 */ template void BinaryTree::PostOrder() { InnerPostOrder(root); } template void BinaryTree::InnerPostOrder(TreeNode *root) { if (!root) { return; } InnerPreorder(root->left); InnerPreorder(root->right); cout data Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-31 20:35:22 "},"算法/":{"url":"算法/","title":"算法","keywords":"","body":"算法 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 19:56:45 "},"版本管理/":{"url":"版本管理/","title":"版本管理","keywords":"","body":"版本管理 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 14:30:12 "},"版本管理/part1.html":{"url":"版本管理/part1.html","title":"Git常用命令","keywords":"","body":"Git常用命令 git config //查看当前目录Git配置信息 git config --list //查看全局Git配置信息 git config --global --list //查看当前目录Git配置的用户邮箱 git config user.email //配置当前目录Git的用户名字 git config user.name \"ThisMJ\" git subtree //父仓库中添加子仓库， git subtree add --prefix=_book git@github.com:thismj/Notebook.git gh-pages --squash //从源仓库拉取更新 git subtree push --prefix=_book git@github.com:thismj/Notebook.git gh-pages //推送本地修改到源仓库 git subtree push --prefix=_book git@github.com:thismj/Notebook.git gh-pages Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 16:08:41 "}}
{"./":{"url":"./","title":"知识笔记","keywords":"","body":"学习笔记整理 旨在建立自己的知识体系，成为一个胸有成竹的人 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-11 15:47:55 "},"interview/":{"url":"interview/","title":"Interview","keywords":"","body":"Interview Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-11-05 10:03:01 "},"interview/Java.html":{"url":"interview/Java.html","title":"Java","keywords":"","body":" Java Java基础 基本类型 自动装箱与拆箱 String、StringBuffer、StringBuilder Java是值传递还是引用传递？ ==、equal()、和hashcode() 泛型擦除、协变、逆变、通配符 四种引用类型 final、finally、finalize区别 反射 异常 注解 其它 Java7 新特性 Java8 新特性 Java集合 List Queue MAP SET Java IO Java并发 进程与线程 创建线程 守护线程 线程的状态 中断线程 锁 线程池 Java Java基础 基本类型 类型 封装类型 长度 取值范围 byte Byte 1字节 -2^7 ~ 2^7-1 short Short 2字节 -2^15 ~ 2^15-1 int Integer 4字节 -2^31 ~ 2^31-1 long Long 8字节 -2^63 ~ 2^63-1 float Float 4字节 1.401298e-45 ~ 3.402823e+38 double Double 8字节 4.9000000e-324 ~ 1.797693e+308 char Character 2字节 0 ~ 65535 boolean Boolean ? true 、false 参考文章 上面基本类型的字节长度是从 Java 语言角度来表述的，其明确了不同类型的取值范围。但是 JVM 在字节码层面上支持的整数类型只有 int 和 long（为啥？JVM 字节码指令是单字节的，最多只有256条，为了节省指令数目，不可能每种类型都占用一个指令），所有比 int 小的整数类型都会被提升为 int 来运算，所以单纯从运算效率来看，使用byte、 short 跟 int、long 没有啥区别。但是基本类型作为对象的字段或者数组元素储存时，确实是占用上表中对应的字节长度，所以使用合适的基本类型是可以节省空间的。 boolean占几个字节？作为对象的字段或者数组元素储存时，占一个字节；在运算的时候（栈帧，局部变量表）会提升到 int，即4个字节（依赖 JVM 具体的实现） Integer.parseInt() 跟 Integer.valueOf() 方法的异同？parseInt() 返回的是基本类型 int，valueOf() 返回的是包装类型 Integer，当方法参数是字符串类型时，valueOf() 内部调用了parseInt() 方法。valueOf() 方法，有 IntegerCache 的缓存，默认是 -128 ～ 127，可以通过 JVM 参数来指定最大值 1.1 字面量属于 double 类型，1 字面量属于 int 类型 float f = 1.1; //无法隐式向下转型，编译错误 byte b1 = 129; //无法隐式向下转型，编译错误 byte b2 = 12; b2 += 128; //隐式向下转型，被编译成 b2 = (byte)(b2 + 128) A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T)((E1) op >(E2)), where T is the type of E1, except that E1 is evaluated only once. 自动装箱与拆箱 Java自动装箱/拆箱 以 Integer 为例子，Java在编译的时候，当我们变量声明为对象类型而赋值为基本数据类型时，则使用 Integer.valueOf() 进行装箱。当我们的变量声明为基本类型而赋值为对象类型时，则使用 Integer.intValue() 进行拆箱。 String、StringBuffer、StringBuilder Java中String、StringBuffer、StringBuilder的区别详解 深入理解StringBuffer和StringBuilder JAVA 中的 StringBuilder 和 StringBuffer 适用的场景是什么？ Java 中 String 类为什么要设计成不可变的 请别再拿“String s = new String(\"xyz\");创建了多少个String实例”来面试了吧 java中这条语句创建了几个对象？ 深入解析String#intern 上面的文章 intern 正确使用的例子，不是说创建的字符串会少 100w 倍，而是gc之后，堆中存留的字符串少 100w 倍。 string转换成integer的方式及原理 Java是值传递还是引用传递？ 参考文章 对基本类型来说，变量的值就是其对应的值；对引用类型来说，变量的值是其指向对象的地址值。 在Java中本质上都是值传递，即把实参变量的值拷贝给形参变量，只不过意义不一样，基本类型拷贝的是它代表的值，引用类型拷贝的是它所指向对象的地址值. ==、equal()、和hashcode() ==：比较的是值是否相等，对基本类型来说，就是比较它们所代表的值；对引用类型来说，就是比较它们所指向对象的地址值。 equal()： 比较的是两个对象的内容是否相同，如果没有重写这个方法，则与 == 作用一样。 hashcode()：获取对象的hash值，一个 int 类型的整数 参考文章 equal()重写规则： 自反性。对于任何非 null 的引用值 x，x.equals(x) 应返回 true。 对称性。对于任何非 null 的引用值 x 与 y ，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才返回 true 传递性。对于任何非 null 的引用值 x、y 与 z，如果 y.equals(x) 返回 true，y.equals(z) 返回true，那么 x.equals(z) 也应返回true。 一致性。对于任何非 null 的引用值 x 与 y ，假设对象上 equals 比较中的信息没有被修改，则多次调用 x.equals(y) 始终返回 true 或者始终返回 false。 对于任何非空引用值 x，x.equal(null) 应返回 false。 父类与子类的混合比较，如果不遵守上述规则，就会出问题。 为什么重写了 equal() 之后要重写 hashcode() 方法？ hashcode() 默认返回跟对象内存地址有关，如果重写了 equal() 但是不重写 hashcode() 的话，则可能会导致两个不同地址的对象，equal() 是相等的，但是 hashcode() 不相等，导致在使用 Hash 集合的时候（HashMap、HashSet）不能正常工作。 泛型擦除、协变、逆变、通配符 聊聊Java泛型擦除那些事 秒懂Java类型（Type）系统 Java 不能实现真正泛型的原因是什么? Java中的协变与逆变 四种引用类型 Java中的强引用，软引用，弱引用，虚引用有什么用？ final、finally、finalize区别 Java 中的 final、finally、finalize 有什么不同？ Java的finalizer，cleaner等如何实现 为什么Java有GC还需要自己来关闭某些资源？ finalize方法 反射 Java 反射由浅入深 | 进阶必备 学习java应该如何理解反射？ java中的静态变量和Class对象究竟存放在哪个区域？ Java6 的类反射瓶颈 Java 反射到底慢在哪里？ 异常 Java的异常 Java异常处理和设计 深入理解 Java try-with-resource 语法糖 在 JDK 9 中更简洁使用 try-with-resources 语句 注解 JAVA 注解的基本原理 其它 为什么JDK源码中，无限循环大多使用for(;;)而不是while(true)? Java7 新特性 Java8 新特性 https://juejin.im/post/6844903600301293581#heading-7 接口默认方法 default 函数式接口 FunctionInterface 和 lambda 表达式 方法引用 :: Stream 流式 API Optional Date/Time API Repeatable重复注解 StringJoiner Java集合 List ArayList 底层通过动态数组实现，RandomAccess标记，支持快速随机访问，查询数据快，增删元素慢（数据需要移位，拷贝数组） ArayList 调用空构造函数，第一次添加元素时会创建一个默认长度为10的数组，后续以 1.5 倍进行扩容；调用 int 参数函数，则默认创建参数大小的数组，后续以 1.5 倍 （oldCapacity + (oldCapacity >> 1) 进行扩容，参数传 0 跟默认空构造函数是不一样的，它会以1、2、3、4......大小进行扩容。（上述为Java 1.8 的实现，Java 1.6的空构造函数会默认创建一个容量为10的数组，并且是以 (oldCapacity * 3)/2 + 1 进行的） ArayList底层数组使用 transient 修饰是因为 ArrayList 的底层数组扩容之后一般会有预留空间（这也是 为什么 List 元素个数叫 size() 而数组叫 length() 的原因），所以序列化整个底层数组没有意义，影响效率，浪费空间。ArrayList 重写了 writeObject() 方法，只序列化确实存在的 size() 个元素。 Vector 和 ArayList ：都是动态数组实现，但是Vector是线程安全的，关键方法都加了 synchronized 修饰；Vector 的扩容策略是 oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity) ，可以通过构造函数指定每次扩容的大小，如果未指定则以 2 倍进行扩容（Java 1.8） SynchronizedList和Vector的区别 Java里用Iterator遍历一个ArrayList里的数据比直接用ArrayList里的方法访问整个List里的数据要好吗？ 增强性 for 循环原理是 iterator，在迭代遍历时，多线程环境下其它线程对集合做增删操作时（单线程在循环体里面做增删操作也会导致，但是可以用 iterator remove方法防止），会导致 modCount != expectedModCount 从而 throw ConcurrentModificationException（并发修改异常） CopyOnWriteArrayList你都不知道，怎么拿offer？ Stack LIFO继承自 Vector，被 Deque 取代了 LinkedList：双向链表实现，增删元素时首先判断 index 是处于当前集合 size>>1 的前面还是后面。前面从 first 头指针开始遍历查找，后面从 last 指针开始遍历查找，增删操作比 ArrayList 效率高，只需要更新引用即可；LInkedList 实现了 Deque 的接口，也相当于是双端队列的链式储存结构，顺序储存结构可以用 ArrayDeque Queue Java之Queue接口中add()/offer()、remove()/poll()、element()/peek()的区别 LinkedList是链式结构，ArrayDeque是动态数组会自动扩容，不会出现满队列的情况，所以这两个容器的 add()/offer() 方法无区别 Stack and Queue ArrayDeque：双端循环队列，循序储存结构 BlockQueue添加了 put()/take() 这一对阻塞性方法,当队列满/空时会阻塞住线程,直到队列有空间/有元素,一些关键性的增删操作也加了锁,所以是线程安全的 ArrayBlockQueue：双端阻塞队列,循序储存结构,实现了 BlockQueue 的 put()/take() 方法 (必须指定队列长度并且不会自动扩容). LinkedBlockingQueue: 双端阻塞队列,链式储存结构,实现了 BlockQueue 的 put()/take() 方法(如果不指定队列长度,默认容量为 Integer.MAX_VALUE) PriorityBlockingQueue:二叉堆,顺序储存结构, 可以传入 Comparator,使队列的元素按照优先级排列, 添加元素 add/offer/put 会自动扩容,获取元素 take 阻塞.二叉堆及优先级队列的实现原理 漫画：什么是二叉堆？（修正版） SynchronousQueue 两种模式，公平模式内部使用队列实现，非公平模式内部使用栈来实现，数据结构里面储存的结点包括数据元素、线程和区分是入队还是出队的标志位，使用CAS来实现非阻塞性的线程安全；如果是相同的操作则入队，如果不是相同的操作则出队。 阻塞队列之SynchronousQueue源码分析 ConcurrentLinkedQueue：ConcurrentLinkedQueue源码分析 非阻塞队列，使用CAS来保证线程安全 MAP HashMap HashMap源码分析，基于1.8，对比1.7 Java 8系列之重新认识HashMap key、value 都可以为 null，key 为 null 时 hashcode 为 0 1.7采用数组链表法来解决哈希冲突，1.8当链表长度达到 8 时会转为红黑树，当元素小于6的时候会转回链表 通过对数组 table size 取余来找到 hash 对应的数组位置 table[(size-1)&hashCode]，低位与(&)运算，即取余。计算 key 的 hashCode 时，通过扰动函数使哈希分配更均匀 (h = key.hashCode()) ^ (h >>> 16) ，使 hashCode 值的所有位都参与到上述取余运算（1.7对hashcode进行4次抖动...没太大意义） 数组 table 的 size 会被计算第一个大于 initialCapacity 并且满足为 2^n 的数；为啥要是 2^n？首先是通过取余运算能使 hash 平均分配在数组的各个位置，而通过 hash 值找到数组下标是通过位运算来的（table[(size-1)&hashCode]），当 size=2^n 时，size-1 二进制位全是1，& hashCode 后恰好保留了它的低位数据， 等价于取余 hashCode % size，效率高。（为了效率、为了 hash 位置的平均分配） table数组元素超过 threshold 时会进行扩容，table size扩容为两倍；threshold = 数组的长度legth*负载因子loadFactor（默认是0.75f） 1.7 扩容时遍历数组链表，根据结点 node 保存的 hash 值来找到在新数组的下标位置，链表元素转移时采用头插法（时间复杂度位O(1)） 1.8扩容时链表采用尾插法 1.7采用头插法将待转移元素插入到新hash桶链表中，高并发场景下会产生链表环，从而导致 Get 不存在元素时发生死循环 高并发下的HashMap JDK 1.8采用尾插法，规避了死循环的情况 LinkedHashMap 搞懂 Java LinkedHashMap 源码 维护了一个双向链表，在一定条件下可以使遍历顺序跟添加顺序一致，取决于这个参数accessOrder，为 true 时遍历基于访问顺序，为 false 时基于插入顺序 HashTable 线程安全的HashMap，关键方法都加了 synchronized 修饰，阻塞性线程安全实现 不支持 key 与 value 为 null（并发情况不支持 key 跟 value 为 null） HashMap 是 Iterator 迭代器，支持 fail-fast （modCount）；Hashtable 是 Enumeration 迭代器，不支持 fail-fast （？？看HashTable 1.8 的代码，Enumeration 也实现了 Iterator 的方法？？ what？？？） TreeMap 红黑树，二叉查找，排序场景使用，需要传入比较器（Comparator）或者类本身实现了 Comparable 接口 ConcurrentHashMap 什么是ConcurrentHashMap？ 1.7: 分段加锁技术，Segment 数组（Segment 继承自 ReentrantLock）+HashEntry数组（数组链表法），不同的 Segment 可以并发读写，同一个 Segment 读跟写也可以并发（读操作不加锁），同一个Segment 写跟写会阻塞（写操作加锁）；锁的粒度变小；size 方法循环统计 Segments 元素个数，通过判断对 segments 的修改次数，决定是否重新统计，超过重试次数，对每个 Segment 加锁，最后做一次统计。 1.8: 不再有 Segment 的概念，跟 1.8 hashMap的数据结构一致，数组+链表或红黑树，对每一个桶结点加锁（同步锁），锁的粒度更小了 SET HashSet 内部有一个 HashMap 的成员变量以及 Object PRESENT = new Object()，每次添加元素的元素作为 key，PRESENT 作为 value LinkedHashSet 内部为 LinkedHashMap 实现 TreeSet 内部为 TreeMap 实现 Java IO Java IO/NIO/AIO - Overview NIO相关基础篇 阻塞性I/O 非阻塞性I/O IO多路复用 单线程处理多个I/O请求，select/poll/epoll 信号驱动I/O 异步I/O 【IO】深入理解管道(PipedInputStream、PipedOutputStream、PipedReader、PipedWriter) 文件 I/O 的内核缓冲 如何学习Java的NIO？ 零拷贝实现 面试被问到“零拷贝”！你真的理解吗？ 所有现代操作系统都使用虚拟内存，使用虚拟的地址取代物理地址，这样做的好处是：1.一个以上的虚拟地址可以指向同一个物理内存地址， 2.虚拟内存空间可大于实际可用的物理地址；利用第一条特性可以把内核空间地址和用户空间的虚拟地址映射到同一个物理地址，这样DMA就可以填充对内核和用户空间进程同时可见的缓冲区了 1、mmap+write 内存映射文件 认真分析mmap：是什么 为什么 怎么用 2、senfile Java实现，FileChannel.transferTo .transferFrom，两次拷贝DMA拷贝，从磁盘拷贝到内存缓冲区，从内存缓冲区拷贝到磁盘，没有CPU拷贝 Java并发 进程与线程 进程是操作系统进行资源分配和调度的基本单位，每个进程都有自己独立的内存空间，进程间的切换开销比较大。 线程是 cpu 调度的最小单位，一个进程包括1个或多个线程，一般来说线程共享所在进程的内存空间和资源，每个线程有自己独立的运行栈和程序计数器，线程切换开销小。 Unix系统中通过 fork、vfork 创建进程，通过 pthread_create 创建线程。 创建线程 jvm把线程分为前台线程和后台线程（守护线程），通过 Thread 类正常创建的都是前台线程，可以在线程 start() 前调用 setDaemon(true) 方法将线程改变为守护线程，jvm结束的条件是所有的前台线程结束。 可以通过以下方法在 Java 中创建线程： public class JavaTest { private static class MyThread extends Thread { @Override public void run() { System.out.println(\"MyThread.run\"); } } private static class MyRunnable implements Runnable { @Override public void run() { System.out.println(\"MyRunnable.run\"); } } private static class MyCallable implements Callable { @Override public Integer call() throws Exception { return 0; } } public static void main(String[] args) { //扩展Thread类 MyThread threadA = new MyThread(); //实现Runnable接口 Thread threadB = new Thread(new MyRunnable()); threadA.start(); threadB.start(); //线程池 ExecutorService executor = Executors.newCachedThreadPool(); executor.submit(new MyRunnable()); Future future = executor.submit(new MyCallable()); } } 线程创建规则： 在 A 线程中创建 B 线程，则默认情况下 B 的优先级、是否守护线程与 A 相同。 守护线程 从 JVM 视角看看 Java 守护线程 线程的状态 Java 线程的 6 种状态定义在 java.lang.Thread$State 枚举类，这些状态是 JVM 状态，它不反映任何操作系统的线程状态。 Java线程的6种状态及切换(透彻讲解) Java中Thread类的join方法到底是如何实现等待的？ 一个锁对应一个同步队列。 WAITTING对应的是等待队列，BLOCKED对应的是同步队列；等待队列中的线程收到 notify/notifyAll 的通知后会进入同步队列，当锁释放之后，同步队列中争抢到锁的线程进入 RUNNABLE 状态，等待系统调度获取 CPU 时间分片继续执行。 join() 方法用 synchronized 修饰，并且内部是用 wait() 方法来实现。在 A 线程中调用 B.join() 时，A 首先要获取 B 对象锁，然后实际上调用了 B 的 wait() 方法，此时 A 释放 B 对象锁，A 进入等待队列，等 B 线程执行完毕后，JVM 内部会调用 B 的 notifyAll 方法，此时 A 线程从等待队出队进入RUNNABLE 状态，等待系统调度获取 CPU 时间分片。 NEW 新创建的线程对象，还没有调用 start() 方法 RUNNABLE 处于 RUNNABLE 状态下的线程正在 JVM 中执行，但它可能正在等待来自于操作系统的其它资源。 Java 中的 RUNNABLE 状态实际上是包含了 Ready 与 Running 状态的，线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权，此时处于 Ready 状态。Ready状态的线程在获得 CPU 时间片后变为 Running 状态. 为何 JVM 中没有去区分这两种状态? CPU时间分片通常是很小的，一个线程一次最多只能在CPU 上运行比如 10-20ms 的时间（此时处于 Ready 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度（也即回到 Ready 状态）。通常，Java的线程状态是服务于监控的，如果线程切换得是如此之快，那么区分 Ready 与 Running 就没什么太大意义了。现今主流的 JVM 实现都把 Java 线程一一映射到操作系统底层的线程上，把调度委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装。JVM本身没有做什么实质的调度，把底层的 Ready 及 Running 状态映射上来也没多大意义，因此，统一成为 RUNNABLE 状态是不错的选择。 BLOCKED WAITING TIMED_WAITING TERMINATED 中断线程 java高并发程序设计1-线程停下来（stop,wait,suspend,await,interrupt,join,yield，sleep）的操作 stop 过时，这方法会立刻释放线程所持有的锁，如果正在做同步操作，会产生很多未知的错误。 suspend/resume 过时，这玩意儿有死锁倾向，因为 suspend 之后不会释放持有的锁，这个时候只有调用线程的 resume 方法，让该线程继续工作， 但是如果调用线程的 resume 方法需要它本身持有的锁，则变成死锁了。 wait/notify 调用这两个方法时必须获取该对象的锁，否则会抛出 IllegalMonitorStateException 异常 interrupt/interrupted/isInterrupted Java多线程：中断机制interrupt以及InterruptedException出现的原因 一文搞懂 Java 线程中断 线程中断方式，调用线程的 interrupt 方法，给线程做个中断标记，此时通过 isInterrupted 判断是否有中断标志位；interrupted 方法是 static 方法，返回当前线程是否有中断标志位，并清除当前的标志位。 若是我们调用线程的中断方法，当程序即将进入或是已经进入阻塞调用的时候，那么这个中断信号应该由InterruptedException捕获并进行重置；当run()方法程序段中不会出现阻塞操作的时候，这时候中断并不会抛出异常，我们需要通过interrupted()方法进行中断检查和中断标志的重置。另外，知道IO操作和synchronized上的阻塞不可中断也是必要的。 自己动手写把”锁”---LockSupport深入浅出 每个线程都有一个许可(permit)，permit只有两个值1和0,默认是0。 当调用unpark(thread)方法，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)。 当调用park()方法，如果当前线程的permit是1，那么将permit设置为0，并立即返回。如果当前线程的permit是0，那么当前线程就会阻塞，直到别的线程将当前线程的permit设置为1.park方法会将permit再次设置为0，并返回。 注意：因为permit默认是0，所以一开始调用park()方法，线程必定会被阻塞。调用unpark(thread)方法后，会自动唤醒thread线程，即park方法立即返回。 带 blocker 的 park 方法可以提供传递给开发人员更多的信息，帮助监视工具和诊断工具确定线程收阻塞的原因。 锁 面试必问的CAS，你懂了吗？ 死磕Synchronized底层实现 不可不说的Java“锁”事 Java 1.6之前都是 Synchronized 都是重量级锁，利用操作系统底层的同步机制实现，对象头的 mark word 指向一个堆中 monitor 对象的指针 无锁->偏向锁->轻量级锁->重量级锁 谈谈 synchronized 和 ReentrantLock 的区别 volatile JMM：Java内存模型 为什么Java的内存模型规范要这样定义导致出现线程本地内存和主存的值不同步呢？为啥线程要有自己的本地内存？ 答案是利用缓存和改变执行代码顺序达到程序执行效率优化。 关键字: volatile详解 线程池 Java线程池实现原理及其在美团业务中的实践 关于线程池你不得不知道的一些设置 Timer、ScheduledThreadPoolExecutor 的区别 Timer使用的是绝对时间，系统时间的改变会对Timer产生一定的影响；而ScheduledThreadPoolExecutor使用的是相对时间，所以不会有这个问题。 Timer使用单线程来处理任务，长时间运行的任务会导致其他任务的延时处理，而ScheduledThreadPoolExecutor可以自定义线程数量。 Timer没有对运行时异常进行处理，一旦某个任务触发运行时异常，会导致整个Timer崩溃，而ScheduledThreadPoolExecutor对运行时异常做了捕获（可以在afterExecute()回调方法中进行处理），所以更加安全。 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-04 19:59:54 "},"interview/Kotlin.html":{"url":"interview/Kotlin.html","title":"Kotlin","keywords":"","body":"Kotlin Kotlin 名字来源于俄罗斯芬兰湾中一个岛屿的名字，全称是 Kotlin Island，是英语「科特林岛」之意。 变量和属性 Java 中的一些关于变量的概念定义： 概念 描述 Field（字段） 类的成员变量，包括非静态的实例变量、静态的类变量 Local Variable（局部变量） 方法体或者静态代码块内定义的变量 Parameter（参数） 方法调用声明的参数 什么是属性？属性的概念比较抽象，它是一个用户可以改变的对象特征，其本质上而言是可以从对象外部公开访问的Field，Kotlin的属性提供了这样一种一致性，即对象的属性只能通过访问器访问。 Kotlin 用关键字 var 定义可变属性，可以重新赋值；val 定义不可变属性，只能赋值一次。属性可以声明在代码文件顶层，作为顶层属性。 声明一个属性的完整写法： var [: ] [= ] [] [] 为什么会有 幕后字段 ？首先，在 Kotlin 中得把属性跟 Java 中字段的含义区分开，不管是在类内部还是外部，属性都是通过 getter、setter 来访问的，它不是字段，举个例子： 在 Kotlin 中定义一个属性 name，此时自定义实现它的 getter、setter 访问器，并且不使用 field 字段，此时查看字节码，是没有生成 name 这个字段的，而只有 getName、setName 两个方法而已，从这儿可以看出，虽然有 name 这个属性，但是并没有 name 这个字段。但是不能说它们没有关系，只要 getter、setter 至少有一个使用了默认实现，或者在自定义的 getter、setter 中使用了 field 这个变量，此时就会生成一个 name 属性对应的 name 字段，而此字段则是 kotlin 中所谓的 幕后字段，并且幕后字段只能在 getter、setter 里面使用。如果 幕后字段 存在，并且没有指定为延迟初始化或延迟加载，也不是抽象的，则必须具有初始化器。 还有一个 幕后属性 的概念，官方文档举例的使用场景是，如果类中需要一个属性，对外表现为 val 只读，对内表现为 var 可读写，则可以这么写： private var _table: Map? = null public val table: Map get() { if (_table == null) { _table = HashMap() // 类型参数已推断出 } return _table ?: throw AssertionError(\"Set to null by another thread\") } 如果属性被声明为 private 的话，则默认不会生成 getter、setter，所以使用 _table 属性的时候不会产生函数调用开销。 结合 幕后字段 的理解，可以认为上述代码只会生成一个名字为 _table 的字段，以及一个 getTable() 的方法。 疑问，如果仅仅只是要属性对外只读对内可读写的话，下面的方法不是也可以吗： var table: Map? = null private set Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-04 19:51:56 "},"interview/Jvm.html":{"url":"interview/Jvm.html","title":"JVM","keywords":"","body":"JVM 类加载机制 类加载机制 动态代理 装饰模式与代理模式的区别 https://www.cxyxiaowu.com/6272.html) Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-11-24 09:52:49 "},"interview/数据结构.html":{"url":"interview/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 数据结构 二叉堆(小根堆、大根堆) 二叉查找树 BST AVL平衡二叉树 B树、B+树 数据结构 二叉堆(小根堆、大根堆) 二叉查找树 BST 最通俗易懂的二叉查找树(BST)详解 AVL平衡二叉树 看图轻松理解数据结构与算法系列(AVL树) B树、B+树 漫画算法：什么是 B 树？ [【面试现场】为什么MySQL数据库要用B+树存储索引？]( Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-11-05 10:02:09 "},"interview/算法.html":{"url":"interview/算法.html","title":"算法","keywords":"","body":"算法 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 20:13:29 "},"interview/计算机网络.html":{"url":"interview/计算机网络.html","title":"计算机网络","keywords":"","body":"计算机网络 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-11-05 09:56:15 "},"interview/Android.html":{"url":"interview/Android.html","title":"Android","keywords":"","body":"Android Activity 生命周期 Intent 启动模式 Context Fragment 生命周期 概述 管理与事务 懒加载 View Paint AndroidX Android gradle ViewBinding 易出错的地方 Activity 生命周期 onRestart可以代替onResume做一些数据刷新的操作。 onStart和onStop：是否可见的角度。onStart代表即将可见，但是用户不能与之交互；onStop代表完全不可见 onPause和onResume：是否处于前台，用户可与之交互的角度。例如 A Activity 启动一个 windowIsFloating 或者 windowIsTranslucent 主题的 B Activity时，A只会回调 onPause，不会进入 onStop，因为此时 A Activity 还是部分可见的，但是用户不能与之交互。 先启动A: A.onCreate() -> A.onStart() -> A.onResume() 再从A中启动B: A.onPause() -> B.onCreate() -> B.onStart() -> B.onResume() -> A.onStop() 按返回键从B回到A：B.onPause() -> A.onRestart() -> A.onStart() -> A.onResume() -> B.onStop() -> B.onDestroy() 从 A 启动 B 时，首先 A onPause() ，此时用户无法与A交互了，然后 B 依次 onCreate() -> onStart()->onResume()，此时 B 可见且可以交互了，所以 A 完全不可见进入 onStop() onWindowFocusChanged()：Activity获取或失去焦点时的回调，例如在 Activity 中拉下系统状态面板，则 Activity 会失去焦点，再拉上去又回重新获取到焦点。可以在这个回调中获取View的宽高 onContentChanged()：setContentView()或者addContentView()方法执行导致Activity的View发生变化时回调 onPostCreate()/onPostResume(): onPostCreate() 在 onStart() 之后，onPostResume() 在 onResume() 之后。 Android onSaveInstanceState()和onRestoreInstanceState()调用时机 Android 横竖屏切换：从Android 3.2开始，横竖屏切换时，screenSize也会发生变化，所以需要配置 \"android:configChanges=\"orientation|screenSize\"，Activity才不会重启，只会回调 onConfigurationChanged() 方法 监听 Home 按键：监听 \"android.intent.action.CLOSE_SYSTEM_DIALOGS\" 广播，获取 \"reason\" 字段携带的值，判断是 多任务案按键 还是 home 按键； onUserLeaveHint() / onUserInteraction()：举例：按下 home 按键或者或者启动一个新的 Activity，则当前Activity会回调 onUserLeaveHint() 方法 Intent 显式Intent 隐式Intent 为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent 过滤器 Intent Filter匹配规则 action：一个Intent Filter中可声明多个action，Intent中的action与其中的任一个action在字符串形式上完全相同（注意，区分大小写，大小写不同但字符串内容相同也会造成匹配失败），action方面就匹配成功。隐式Intent必须指定action（如不指定action则必须指定data或mimetype，这种情况下，只要IntentFilter至少含有一个action就可以匹配）。 category：Intent中个如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同；Intent中也可以没有category（若Intent中未指定category，系统会自动为它带上“android.intent.category.DEFAULT”，所以，如果你的 activity支持接收隐式intent的话就一定要在intent filter中加入android.intent.category.DEFAULT data：URI完全匹配 ://:/ mimeType 这二者共同出现，标明该Activity是一个入口Activity，并且会出现在系统应用列表中，二者缺一不可。 启动模式 解开Android应用程序组件Activity的\"singleTask\"之谜 Android中Activity四种启动模式和taskAffinity属性详解 1、针对 launchmode 为 SingleTask 的 Activity，代表该 Activity 可以通过创建新 task 的方式启动，但是是否真的创建新的 task，还有其他条件的限制，例如：需要指定与启动该Activity task 不同的 taskAffinity、不是通过 startActivityForResult 启动该 Activity 2、在启动一个singleTask的Activity实例时，如果系统中已经存在这样一个实例，就会将这个实例调度到任务栈的栈顶，并清除它当前所在任务中位于它上面的所有的activity 3、以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activity时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 4、以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中 ACTIVITY 的属性ANDROID:TASKAFFINITY和ANDROID:ALLOWTASKREPARENTING android:allowTaskReparenting：如果一个 Activity 没有指定为 SingleTask 或者设置了 FLAG_ACTIVITY_NEW_TASK，则没有创建新 task 的能力，所以只能在启动它的 task 里面（例如A应用启动了B应用的某个Activity），如果此时一个具有跟该 Activity 相同 taskAffinity 的 task 进入前台，该属性值指定为 true 时，该 Activity 就会重新转移到这个 task 里面去。 android:alwaysRetainTaskState：task长时间处于后台，重新进入的时候是否会保留 task 里面的所有activity，默认是 false，代表会清除根Activity之外其他所有的Activity。该属性只对 task 的根 Activity 起作用。 android:clearTaskOnLaunch：当task重新进入前台时，是否清除除根 Activity 之外的所有 Activity ，默认是false。该属性只对 task 的根 Activity 起作用。 android:finishOnTaskLaunch：当task重新进入前台时，是否关闭该Activity，优先级比 allowTaskReparenting 高。对 task 中的所有 Activity 有效。 Intent.FLAG_ACTIVITY_CLEAR_TOP：如果task中存在对应activity的实例，例如A->B->C（都是标准启动模式），此时在启动一个A，则首先B.onDestroyed()->C.onPause()->A.onDestroy()->A重新创建->C.onStop()->C.onDestory() Intent.FLAG_ACTIVITY_NEW_TASK：当启动一个activity时如果具有此标记位，代表新启动的app是可以创建一个新的task的，当然不一定会启动新的task，具体参考上面的 Singletask 模式 Intent.FLAG_ACTIVITY_SINGLE_TOP：如果task中栈顶是该activity的实例，则不会创建新的activity，会依次调用该activity的 onPause()->onNewIntent()->onResume() SingleTask模式 = Intent.FLAG_ACTIVITY_NEW_TASK（能创建新的task ）+ Intent.FLAG_ACTIVITY_CLEAR_TOP + Intent.FLAG_ACTIVITY_SINGLE_TOP （task栈内复用） Context 面试官灵魂发问：你真的懂 Context 吗？ ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类，ContextWrapper装饰ContextImpl。而ContextWrapper又有三个直接的子类， ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。 getApplication()只能在activity、service里面调用，getApplicationContext()只要有Context的实例就能调用到 ccontext.getApplicationContext(); getBaseContext获取ContextWrapper里面包装的ContextImpl对象 Context的数量 = Activity的数量+Service的数量+1（Application） 非Activity的Context做一些 Activity Context 的操作： 非Activity的Context（ContextWrapper）启动Activity需要必须增加 Intent.FLAG_ACTIVITY_NEW_TASK 的Flag，因为非Activity的Context调用startActivity默认是调用了ContextImpl 的startActivity方法，内部有判断 Intent 是否包含Intent.FLAG_ACTIVITY_NEW_TASK，没有则抛出AndroidRuntimeException 非Activity的Context inflate layout 会使用系统默认的主题样式 非Activity的Context不能 show 普通的dialog（应用窗口类型1-99），WMS会校验token，返回对应的错误码，APP进程收到之后抛出 WindowManager.BadTokenException AMS 在启动 Activity 的时候，会构建表示 Activity 信息的 ActivityRecord 对象，其构造函数中会实例化 Token 对象 AMS 在接着上一步之后，会利用创建的 Token 构建 AppWindowContainerController 对象，最终将 Token 存储到 WMS 中的 mTokenMap 中 WMS 在 addWindow 时，会根据当前 Window 对象的 Token 进行校验 if (type >= FIRST_APPLICATION_WINDOW && type 非Activity的Context parentWindow 为空所以不会调用 adjustLayoutParamsForSubWindow，从而引发 BadTokenException 在View中对 context 强转出现 ClassCastException：android.view.ContextThemeWrapper cannot be cast to Activity Fragment 生命周期 概述 Fragment：理解为针对 View 的一个封装框架 管理与事务 FragmentManager：Fragment管理抽象类，定义了可以对外暴露的Fragment出栈、查找栈中添加的Fragment、获得事务对象等方法；FragmentManagerImpl是FragmentManager的实现类。getChildFragmetManager、getFragmentManager、getSupportFragmentManager FragmentTransaction：定义了对Fragment的事务操作，add、remove、hide、show等方法，以及commit、commitAllowingStateLoss（异步，通过Activity的handler抛事件）、commitNow、commitNowAllowingStateLoss（同步，不允许添加进fragment栈，不然会影响其他异步的事务），具体实现类为 BackStackRecord，里面用链表维护保存事务的所有操作（Op） Fragment操作方法和生命周期的关系 Android高频面试专题 - 基础篇（二）Fragment 懒加载 Androidx 下 Fragment 懒加载的新实现 老的懒加载实现：如果是 FragmentManager add、show/hide 的形式，则借助 Fragment 的 onHiddenChanged 方法来实现只有当前显示的 Fragment 才加载数据；如果是 Viewpager+FragmentPagerAdapter 的形式，则借助 Fragment 的 setUserVisibleHint 方法来实现； AndroidX：setUserVisibleHint被标记为过时了，Viewpager+FragmentPagerAdapter 的形式可以使用 FragmentTransaction 的 setMaxLifecycle 来实现懒加载，构造 FragmentPagerAdapter 的时候传 behavior 为 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT，则内部会通过 setMaxLifecycle 来自动处理，确保只有显示的 Fragment 才回调 onResume 方法 FragmentPagerAdapter更多的用于相对静态的、少量界面的ViewPager，划过的fragment会保存在内存中，如果加载的fragment较多会占用大量的内存，处于当前显示的 Fragment 前后 limit （通过 setOffscreenPageLimit() 设置）个以外的 Fragment 只会调用 onDestroyView，并不会onDestroy、onDetach。而FragmentStatePagerAdapter适用于数据动态性较大、页面比较多的情况，它并不会保存所有的fragment，只会保存当前显示的Fragment以及其前后 limit 个，其他会被销毁掉onDestroy、onDetach。 View EditText android:imeOptions 属性 自定义View Paint 绘制文本drawText() fun Canvas.drawTextByPoint( text: String, x: Float, y: Float, paint: Paint, align: Paint.Align = Paint.Align.CENTER ) { val fontMetrics = paint.fontMetrics val textWidth = paint.measureText(text) //基于y使文本居中计算绘制的baseline val baseLine = y - (fontMetrics.top + fontMetrics.bottom) / 2 val drawX = when (align) { Paint.Align.LEFT -> x Paint.Align.CENTER -> x - textWidth / 2 Paint.Align.RIGHT -> x - textWidth } drawText(text, drawX, baseLine, paint) } AndroidX Android gradle ViewBinding 易出错的地方 LayoutInflater inflate 时如果 parent 传了 ull，则根布局设置的 layout params 无效，所以在布局里面设置了 layout_width 也无济于事了。 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-03 16:48:22 "},"interview/AndroidX.html":{"url":"interview/AndroidX.html","title":"AndroidX","keywords":"","body":"AndroidX LifeCycle Lifecycle LiveData ViewModel 什么是AndroidX androidx命名空间包含了 Android Jetpack、以及重构了之前的 Support 库（28.0.0是最后一个版本了）等。AndroidX 中的库都会单独维护和更新。 LifeCycle //单独依赖下述库时，Android Gradle插件会自动添加部分依赖 //lifecycle-runtime-ktx //lifecycle-common //lifecycle-runtime implementation \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\" //lifecycle-viewmodel-ktx //lifecycle-viewmodel implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\" //lifecycle-livedata-ktx //lifecycle-livedata-core-ktx //lifecycle-livedata //lifecycle-livedata-core //lifecycle-common implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version\" //lifecycle-viewmodel-savedstate //lifecycle-viewmodel //lifecycle-livedata-core //lifecycle-common implementation \"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version\" //添加此注解处理依赖，会为添加了@OnLifecycleEvent注解的类生成 xxx_LifecycleAdapter，这样就不用在运行的时候通过反射去回调 //Lifecycle中的生命周期感知方法了 kapt \"androidx.lifecycle:lifecycle-compiler:$lifecycle_version\" //Java8接口方法可以声明为default，用下面这个替代lifecycle-compiler，生命周期感知组件直接继承 DefaultLifecycleObserver //重写自己需要回调方法即可 implementation \"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version\" //自定义Service继承LifecycleService，实现Service生命周期感知组件 implementation \"androidx.lifecycle:lifecycle-service:$lifecycle_version\" //应用进程生命周期感知，借助ProcessLifecycleOwnerInitializer(继承自ContentProvider)，来自动初始化ProcessLifecycleOwner，然后通过它来添加应用进程生命周期感知的组件 implementation \"androidx.lifecycle:lifecycle-process:$lifecycle_version\" Lifecycle 处理生命周期 Lifecycle：具有Android组件生命周期的对象，LifecycleRegistry是其实现类 classDiagram class Lifecycle { > +addObserver() +removeObserver() +getCurrentState() State } LifecycleRegistry > ON_CREATE ON_START ON_RESUME ON_PAUSE ON_STOP ON_DESTROY ON_ANY } class State{ > DESTROYED INITIALIZED CREATED STARTED RESUMED } LifecycleOwner：实现getLifecycle()，返回真正的Lifecycle对象(LifecycleRegistry) classDiagram class LifecycleOwner{ > } class ComponentActivity class Fragment Fragment : ~LifecycleRegistry mLifecycleRegistry ComponentActivity : -LifecycleRegistry mLifecycleRegistry Fragment ..|> LifecycleOwner ComponentActivity ..|> LifecycleOwner Fragment --> LifecycleRegistry ComponentActivity --> LifecycleRegistry LifecycleObserver、LifecycleEventObserver、FullLifecycleObserver、DefaultLifecycleObserver classDiagram class LifecycleObserver { > } class LifecycleEventObserver{ > } class FullLifecycleObserver{ > } class DefaultLifecycleObserver{ > } LifecycleObserver 从源码看 Jetpack（1） -Lifecycle源码解析 ReportFragment.injectIfNeededIn()，通过 registerActivityLifecycleCallbacks(SDK>=29) 或者 Fragment(SDK LiveData ViewModel Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-04 20:19:58 "},"interview/Gradle.html":{"url":"interview/Gradle.html","title":"Gradle","keywords":"","body":"Gradle Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 09:51:07 "},"interview/Android源码.html":{"url":"interview/Android源码.html","title":"Android源码","keywords":"","body":"Android源码 Init进程的启动过程 Android系统启动流程（一）解析init进程启动过程 引导芯片代码 -> 加载Bootloader到RAM执行 -> Linux内核启动 -> init进程启动 init.cpp main() 创建一些文件夹并挂载设备 property_init 初始化属性，start_property_service启动属性服务 解析 init.rc、init.zygote32(64).rc -> builtins.cpp do_class_start() fork 子进程 app_main.cpp main() AndroidRuntime.start(\"com.android.internal.os.ZygoteInit\",, args, zygote) Zygote进程启动 Android系统启动流程（二）解析Zygote进程启动过程 AndroidRuntime.start(） startVm() 启动 JavaVM(Dalvik、ART) 虚拟机 startReg() 为虚拟机注册JNI 通过 JNI 调用 ZygoteInit.java 的 main()，从此进 Java 的世界 ZygoteInit.java main() registerZygoteSocket(), 创建Server端的监听Socket 创建sServerSocket (LocalServerSocket) preload()，预加载一些常用的类和资源 startSystemServer() 启动系统服务 Zygote.forkSystemServer() (uid gid设置为1000) ZygoteInit.handleSystemServerProcess 启动SystemServer进程 runSelectLoop() 等待客户端连接(AMS 请求 Zygote 创建新的应用程序进程) SystemServer进程启动 Android系统启动流程（三）解析SyetemServer进程启动过程 ZygoteInit.java startSystemServer() Zygote.forkSystemServer()： fork SystemServer进程 handleSystemServerProcess() ：closeServerSocket()关闭从Zygote进程复制来的Socket；SystemServer进程启动之后的工作 RuntimeInit.zygoteInit： nativeZygoteInit()： AndroidRuntime.cpp com_android_internal_os_RuntimeInit_nativeZygoteInit() AppRuntime.onZygoteInit() ProcessState.startThreadPool()：启动一个Binder线程池，这样SyetemServer进程就可以使用 Binder来与其他进程进行通信了 applicationInit() Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 20:06:54 "},"interview/数据库.html":{"url":"interview/数据库.html","title":"数据库","keywords":"","body":"数据库 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-11-21 15:38:52 "},"interview/文档.html":{"url":"interview/文档.html","title":"文档","keywords":"","body":"文档 Typora不支持最新Mermaid语法的解决办法 Copyright © thismj.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-03 20:57:50 "}}